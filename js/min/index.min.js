function Enemy(t,e,i,n,o){Entity.call(this,t,e,i,n),this.moveType=o,this.isAttacking=!1}function Entity(t,e,i,n){Tile.call(this,t,e,!1),this.health=i,this.maxHealth=i,this.power=n,this.direction=0}function Item(t,e,i){Tile.call(this,t,e,!1),this.buff=i}function Tile(t,e,i){this.i=t,this.j=e,this.isEmpty=i}function Potion(t,e,i){Item.call(this,t,e,i)}function Sword(t,e,i){Item.call(this,t,e,i)}function Enum(t){let e={};for(let i in t)t.hasOwnProperty(i)&&(e[i]=Symbol(t[i]));return Object.freeze(e)}Enemy.prototype.__proto__=Entity.prototype,Enemy.prototype.draw=function(t){Entity.prototype.draw.call(this,t),t.addClass("enemy"),this.drawHealthBar(t),this.isAttacking&&t.addClass("attack")},Entity.prototype.__proto__=Tile.prototype,Entity.prototype.draw=function(t){this.mirrorFlip(t)},Entity.prototype.drawHealthBar=function(t){let e=Math.ceil(this.health/this.maxHealth*100),i=$("<div></div>");i.attr("class","health"),i.css("width",e+"%"),t.append(i)},Entity.prototype.changeDirection=function(t){t===Action.RIGHT&&(this.direction=1),t===Action.LEFT&&(this.direction=-1)},Entity.prototype.mirrorFlip=function(t){this.direction>0?t.addClass("right"):t.addClass("left")},Item.prototype.__proto__=Tile.prototype,Tile.prototype.draw=function(t){t.addClass("wall")},Potion.prototype.__proto__=Item.prototype,Potion.prototype.draw=function(t){t.addClass("potion")},Sword.prototype.__proto__=Item.prototype,Sword.prototype.draw=function(t){t.addClass("sword")};const Action=Enum({UNKNOWN:-1,UP:0,RIGHT:1,DOWN:2,LEFT:3,ATTACK:4});function getDirectionCode(t,e){return -1===t&&0===e?Action.UP:0===t&&1===e?Action.RIGHT:1===t&&0===e?Action.DOWN:0===t&&-1===e?Action.LEFT:Action.UNKNOWN}function getIndexes(t){switch(t){case Action.UP:return{indexDiff:-1,jndexDiff:0};case Action.RIGHT:return{indexDiff:0,jndexDiff:1};case Action.DOWN:return{indexDiff:1,jndexDiff:0};case Action.LEFT:return{indexDiff:0,jndexDiff:-1};default:return{indexDiff:0,jndexDiff:0}}}function getEmptyCells(t){let e=[];for(let i=0;i<t.height;i+=1)for(let n=0;n<t.width;n+=1)if(t.mapMatrix[i][n].isEmpty){let o={i,j:n};e.push(o)}return e}function isHaveEmptyCells(t,e,i){for(let n=0;n<i;n+=1)for(let o=0;o<e;o+=1)if(t[n][o])return!0;return!1}function getEmptyCellsByBorders(t,e){let i=[];for(let n=e.minVerticalBorder;n<=e.maxVerticalBorder;n+=1)for(let o=e.minHorizontalBorder;o<=e.maxHorizontalBorder;o+=1)t[n][o]&&i.push({i:n,j:o});return i}function createMapMatrix(t,e){let i=[];for(let n=0;n<e;n+=1){i[n]=[];for(let o=0;o<t;o+=1)i[n][o]=new Tile(n,o,!1)}return{mapMatrix:i,width:t,height:e}}function generateRooms(t,e,i,n,o){let a=getRandomInRange(e,i),r=t.height,l=0,p=t.width,s=0;for(let c=0;c<a;c+=1){let h=getRandomInRange(n,o),m=getRandomInRange(n,o),f=getRandomInRange(0,t.height-m),d=getRandomInRange(0,t.width-h),u=f+m,y=d+h;for(let _=f;_<u;_+=1)for(let g=d;g<y;g+=1)t.mapMatrix[_][g].isEmpty=!0;f<r&&(r=f),u>l&&(l=u),d<p&&(p=d),y>s&&(s=y)}r+=n,p+=n,l-=n,s-=n;let w={minVerticalBorder:r,maxVerticalBorder:l,minHorizontalBorder:p,maxHorizontalBorder:s};return w}function getRandomIndex(t,e,i){for(;;){let n=getRandomInRange(t,e);if(-1===i.indexOf(n))return i.push(n),n;i.push(n)}}function generateWays(t,e,i,n){let o=getRandomInRange(e,i),a=getRandomInRange(e,i),r=[];for(let l=0;l<o;l+=1){let p=getRandomIndex(n.minVerticalBorder,n.maxVerticalBorder,r);for(let s=0;s<t.width;s+=1)t.mapMatrix[p][s].isEmpty=!0}let c=[];for(let h=0;h<a;h+=1){let m=getRandomIndex(n.minHorizontalBorder,n.maxHorizontalBorder,c);for(let f=0;f<t.height;f+=1)t.mapMatrix[f][m].isEmpty=!0}}function collectSteps(t,e,i,n,o,a){n+1<i&&t[n+1][o]&&(a.push({i:n+1,j:o}),t[n+1][o]=!1),o+1<e&&t[n][o+1]&&(a.push({i:n,j:o+1}),t[n][o+1]=!1),n-1>=0&&t[n-1][o]&&(a.push({i:n-1,j:o}),t[n-1][o]=!1),o-1>=0&&t[n][o-1]&&(a.push({i:n,j:o-1}),t[n][o-1]=!1),t[n][o]=!1}function isMapHaveEmptySpaces(t,e){let i=t.width,n=t.height,o=copyMapMatrix(t),a=getEmptyCellsByBorders(o,e),r=a[Math.ceil(a.length/2)],l=r.i,p=r.j,s=[];for(collectSteps(o,i,n,l,p,s);0!=s.length;){let c=[];for(let h=0;h<s.length;h+=1){let m=s[h],f=m.i,d=m.j;collectSteps(o,i,n,f,d,c)}s=c}return isHaveEmptyCells(o,i,n)}function spawnEntity(t,e,i){let n=e.i,o=e.j,a=i[0],r=i[1],l=i[2],p=i[3];t.mapMatrix[n][o]=new a(n,o,r,l,p)}function spawnItem(t,e,i){let n=e.i,o=e.j,a=i[0],r=i[1];t.mapMatrix[n][o]=new a(n,o,r)}function spawnObjects(t,e,i,...n){for(let o=0;o<e;o+=1){let a=getEmptyCells(t),r=getRandomInRange(0,a.length-1),l=a[r];i(t,l,n)}}function gameInit(t){let e={},i={};do i=generateRooms(e=createMapMatrix(t.width,t.height),t.minRoomCount,t.maxRoomCount,t.minRoomSize,t.maxRoomSize),generateWays(e,t.minWaysCount,t.maxWaysCount,i);while(isMapHaveEmptySpaces(e,i));spawnObjects(e,t.swordCount,spawnItem,Sword,t.swordBuff),spawnObjects(e,t.potionCount,spawnItem,Potion,t.potionBuff),spawnObjects(e,1,spawnEntity,Player,t.playerHealth,t.playerPower);let n=[],o=t.enemyCount;for(let a=0;a<o;a+=1){let r={};r.class_=HumanEnemy,n.push(r)}for(let l=0;l<n.length;l+=1){let p=n[l];spawnObjects(e,1,spawnEntity,p.class_,t.enemyHealth,t.enemyPower)}return e}function moveEntity(t,e,i){let{indexDiff:n,jndexDiff:o}=getIndexes(e),a=i.i,r=i.j,l=mapTeleport(a+n,t.height),p=mapTeleport(r+o,t.width),s=t.mapMatrix[l][p];i.__proto__===Player.prototype&&(i.changeDirection(e),s.__proto__===Potion.prototype?(i.drinkPotion(s),s=new Tile(s.i,s.j,!0)):s.__proto__===Sword.prototype&&(i.takeSword(s),s=new Tile(s.i,s.j,!0))),s.isEmpty&&(t.mapMatrix[l][p]=i,i.i=l,i.j=p,t.mapMatrix[a][r]=s,s.i=a,s.j=r)}function moveEnemies(t,e,i){for(let n=0;n<e.length;n+=1){let o=e[n],a=o.step(t,i);moveEntity(t,a,o)}}function calculateAttacks(t,e,i,n){let o=e.i,a=e.j,r=[];for(let l=0;l<i.length;l+=1){let p=i[l],s=p.i,c=p.j,h=1>=Math.abs(s-o)&&1>=Math.abs(c-a);p.isAttacking=h,h&&(n&&(p.health-=e.power),p.health<=0?r.push(p):e.health-=p.power)}for(let m=r.length-1;m>=0;m-=1){let f=r[m],d=f.i,u=f.j;t.mapMatrix[d][u]=new Tile(d,d,!0)}}const gameStep=(t,e)=>{let i=getObjectsByInstanceOf(t,Player)[0],n=getObjectsByInstanceOf(t,Enemy);moveEnemies(t,n,i),e!==Action.ATTACK&&moveEntity(t,e,i),calculateAttacks(t,i,n,e===Action.ATTACK)};var map={};let multiplier=35;function draw(){let t=$(".field");for(let e=0;e<map.height;e+=1)for(let i=0;i<map.width;i+=1){let n=map.mapMatrix[e][i];if(!n.isEmpty){let o=$("<div></div>");o.attr("class","tile"),o.width(multiplier).height(multiplier),o.offset({top:multiplier*e,left:multiplier*i}),n.draw(o),t.append(o)}}}function isGameOver(){let t=getObjectsByInstanceOf(map,Player)[0],e=getObjectsByInstanceOf(map,Enemy);if(0===e.length||t.health<=0){let i=0===e.length?"Win":"Lose";setTimeout(function(){confirm("Game Over: "+i),window.location.reload()},0)}}function update(t){$(".field").empty(),gameStep(map,t),draw(),isGameOver()}document.addEventListener("keypress",t=>{let e=t.key.toLocaleLowerCase(),i=Action.UNKNOWN;switch(e){case"w":case"ц":i=Action.UP;break;case"d":case"в":i=Action.RIGHT;break;case"s":case"ы":i=Action.DOWN;break;case"a":case"ф":i=Action.LEFT;break;case" ":i=Action.ATTACK}update(i)}),window.addEventListener("load",async t=>{let e=Settings;map=gameInit(e);let i=$(window).width(),n=$(window).height(),o=map.width,a=map.height;multiplier=Math.ceil(.95*Math.min(i/o,n/a));let r=$(".field");r.width(multiplier*o).height(multiplier*a),r.css("background-size",`${multiplier}px`),r.empty(),draw()});const Settings={width:40,height:24,minRoomCount:5,maxRoomCount:10,minRoomSize:3,maxRoomSize:8,minWaysCount:3,maxWaysCount:5,swordCount:2,swordBuff:1,potionCount:10,potionBuff:1,playerPower:2,playerHealth:10,enemyHealth:4,enemyPower:1,enemyCount:10};function getObjectsByInstanceOf(t,e){let i=[];for(let n=0;n<t.height;n+=1)for(let o=0;o<t.width;o+=1){let a=t.mapMatrix[n][o];a instanceof e&&i.push(a)}return i}function getRandomInRange(t,e){return t=Math.ceil(t),Math.floor(Math.random()*((e=Math.floor(e))-t+1))+t}function mapTeleport(t,e){return t<0&&(t=e-1),t>=e&&(t=0),t}function copyMapMatrix(t){let e=[];for(let i=0;i<t.height;i+=1){e[i]=[];for(let n=0;n<t.width;n+=1){let o=t.mapMatrix[i][n].isEmpty;e[i][n]=o}}return e}function HumanEnemy(t,e,i,n,o){Enemy.call(this,t,e,i,n,o)}function Player(t,e,i,n){Entity.call(this,t,e,i,n)}HumanEnemy.prototype.__proto__=Enemy.prototype,HumanEnemy.prototype.draw=function(t){Enemy.prototype.draw.call(this,t),t.addClass("human")},HumanEnemy.prototype.step=function(t,e){let i=[],n=t.width,o=t.height,a=copyMapMatrix(t);for(a[this.i][this.j]=!1,i.push([{i:this.i,j:this.j}]);i.length>0;){let r=i.shift(),l=r[r.length-1],p=[[l.i+1,l.j+0],[l.i+0,l.j+1],[l.i-1,l.j+0],[l.i+0,l.j-1],];for(let s=0;s<p.length;s+=1){if(p[s][0]===e.i&&p[s][1]===e.j){let c=-1;if(r.length>1){let h=r[1];(c=getDirectionCode(h.i-this.i,h.j-this.j))===Action.UNKNOWN&&(h.i===o-1&&0===this.i&&(c=Action.UP),0===h.j&&this.j===n-1&&(c=Action.RIGHT),0===h.i&&this.i===o-1&&(c=Action.DOWN),h.j===n-1&&0===this.j&&(c=Action.LEFT))}return this.changeDirection(c),c}p[s][0]=mapTeleport(p[s][0],t.height),p[s][1]=mapTeleport(p[s][1],t.width),!1!==a[p[s][0]][p[s][1]]&&(a[p[s][0]][p[s][1]]=!1,i.push(r.concat({i:p[s][0],j:p[s][1]})))}}},Player.prototype.__proto__=Entity.prototype,Player.prototype.draw=function(t){Entity.prototype.draw.call(this,t),this.__proto__.__proto__.draw.call(this,t),t.addClass("player"),this.drawHealthBar(t)},Player.prototype.drinkPotion=function(t){this.health<this.maxHealth&&(this.health+=t.buff)},Player.prototype.takeSword=function(t){this.power+=t.buff};